# -------------------------
# p-saturation / specialization checks
# -------------------------
# Note: This module expects `find_singular_fibers` and `find_cm_fibers`
# to be provided by the calling environment.

from sage.all import (
    QQ, GF, EllipticCurve, prime_range, PolynomialRing, FractionField, is_prime,
    matrix, ZZ, next_prime, factor
)
from itertools import product
from search_common import DEBUG, to_mod_poly


# --- Helper Functions ---


def eval_rational_mod(rf, m0, ell):
    """
    Evaluate a rational function rf(m) at integer m0 modulo ell.
    Returns None if evaluation is invalid (pole or denominator 0 mod ell).
    """
    try:
        val = rf.subs({'m': m0})
    except (ZeroDivisionError, TypeError, AttributeError):
        return None  # invalid specialization

    try:
        val_qq = QQ(val)
    except Exception:
        return None

    num = val_qq.numerator()
    den = val_qq.denominator()

    if den % ell == 0:
        return None  # skip this specialization; not a valid reduction

    F = GF(ell)
    return F(num) / F(den)


def discriminant_divisible_by_ell(a4, a6, m0, ell):
    """
    Check if the discriminant Delta = -16*(4*a4^3 + 27*a6^2) at m0
    is divisible by ell.

    Returns True if Delta is 0 mod ell or if evaluation fails (bad reduction).
    """
    a4_mod = eval_rational_mod(a4, m0, ell)
    a6_mod = eval_rational_mod(a6, m0, ell)

    if a4_mod is None or a6_mod is None:
        return True  # Indicates bad reduction due to a pole.

    # Now compute Delta in the finite field.
    delta_mod = -16 * (4 * a4_mod**3 + 27 * a6_mod**2)
    return delta_mod == 0


def reduce_section_at_m0(section, m0, ell, a4, a6):
    """
    Specialize a projective section [X(m), Y(m), Z(m)] at m0 and reduce mod ell.

    Returns a tuple (E0, P_mod) where E0 is the elliptic curve over GF(ell)
    and P_mod is the specialized point, or None if reduction is not possible.
    """
    # Check for bad reduction at the curve level first.
    if discriminant_divisible_by_ell(a4, a6, m0, ell):
        return None  # bad reduction at curve level

    # Evaluate section coordinates.
    try:
        X_rf, Y_rf, Z_rf = section
    except (IndexError, TypeError):
        return None  # Section not in the expected format.

    X_mod = eval_rational_mod(X_rf, m0, ell)
    Y_mod = eval_rational_mod(Y_rf, m0, ell)
    Z_mod = eval_rational_mod(Z_rf, m0, ell)

    if X_mod is None or Y_mod is None or Z_mod is None:
        return None  # one coordinate had a pole mod ell; skip

    # Build the specialized curve E0.
    a4_mod = eval_rational_mod(a4, m0, ell)
    a6_mod = eval_rational_mod(a6, m0, ell)
    if a4_mod is None or a6_mod is None:
        return None  # curve coefficients have pole; skip

    try:
        E0 = EllipticCurve(GF(ell), [0, 0, 0, a4_mod, a6_mod])
        P_mod = E0([X_mod, Y_mod, Z_mod])
        return E0, P_mod
    except (ValueError, TypeError):
        # Point not on curve or invalid reduction
        return None

# --- Saturation Checking Functions ---

def _subgroup_generated_by(points_mod, E_mod):
    """Compute the subgroup generated by a list of points on E_mod using BFS."""
    subgroup = {E_mod(0)}
    points_to_add = {p for p in points_mod if p is not None}
    frontier = points_to_add - subgroup
    
    while frontier:
        new_frontier = set()
        for g in frontier:
            if g not in subgroup:
                subgroup.add(g)
                subgroup.add(-g)
                for h in subgroup:
                    s = g + h
                    if s not in subgroup:
                        new_frontier.add(s)
        frontier = new_frontier
    return subgroup


def _is_subgroup_contained_in_pE(E_mod, subgroup, p):
    """
    Checks if a subgroup is contained in p * E_mod by checking if
    every point in the subgroup is divisible by p.
    """
    for Q in subgroup:
        if Q != E_mod(0) and not Q.is_divisible_by(p):
            return False
    return True


def p_saturate_basis(cd, basis_sections, primes_to_check,
                     m_samples=None, ell_candidates=None,
                     max_m_samples=8, max_ells_per_m=3, verbose=False):
    """
    Checks if the basis sections are p-saturated for a given set of primes.

    A witness of p-saturation is a pair (m0, ell) where the specialized
    subgroup <S_1(m0), ..., S_r(m0)> mod ell is not divisible by p.
    """
    results = {}
    if ell_candidates is None:
        try:
            ell_candidates = choose_good_ell_candidates(cd, required=5)
        except RuntimeError as e:
            if verbose:
                print(f"Warning: Could not choose good ell candidates. Skipping. Error: {e}")
            return {p: (False, None) for p in primes_to_check}
        if not ell_candidates:
            return {p: (False, None) for p in primes_to_check}

    if m_samples is None:
        m_samples = []
        try:
            sing = find_singular_fibers(cd)
            m_samples.extend(QQ(f['r']) for f in sing.get('fibers', [])
                             if f.get('root_type') == 'rational' and f.get('r') is not None)
        except Exception:
            pass
        try:
            cm = find_cm_fibers(cd)
            m_samples.extend(QQ(m0) for m0 in cm)
        except Exception:
            pass
        m_samples.extend(QQ(a) for a in range(-3, 4))
        m_samples = list(dict.fromkeys(m_samples))[:max_m_samples]

    for p in primes_to_check:
        if not isinstance(p, int) or p <= 1:
            continue

        saturated_witness = None
        for m0 in m_samples:
            ells_done = 0
            for ell in ell_candidates:
                if ells_done >= max_ells_per_m:
                    break

                if discriminant_divisible_by_ell(cd.a4, cd.a6, m0, ell):
                    if verbose:
                        print(f"[p_saturate_basis] Skip m0={m0}, ell={ell}: discriminant divisible by ell")
                    continue

                pts_mod = []
                E_mod = None
                specialization_failed = False
                for S in basis_sections:
                    res = reduce_section_at_m0(S, m0, ell, cd.a4, cd.a6)
                    if res is None:
                        specialization_failed = True
                        if verbose:
                            print(f"[p_saturate_basis] Skip section at m0={m0}, ell={ell}: bad reduction")
                        break
                    E_mod_candidate, P_mod = res
                    if E_mod is None:
                        E_mod = E_mod_candidate
                    pts_mod.append(P_mod)

                if specialization_failed or E_mod is None or not pts_mod:
                    continue  # skip; do not treat as unsaturated

                subgroup = _subgroup_generated_by(pts_mod, E_mod)
                contained = _is_subgroup_contained_in_pE(E_mod, subgroup, p)

                if not contained:
                    saturated_witness = {
                        'p': p, 'm0': m0, 'ell': ell,
                        'subgroup_size': len(subgroup),
                        'E_mod_cardinality': E_mod.cardinality()
                    }
                    break
                ells_done += 1
            if saturated_witness is not None:
                break
        results[p] = (saturated_witness is not None, saturated_witness)

    return results


# --- Constructive p-Division Search ---

def get_fp_vectors(r, p):
    """
    Generates all non-zero vectors in (F_p)^r for testing relations.
    Returns a list of tuples.
    """
    if r <= 0:
        return []

    # Optimization: if the space is too large, return a small, fixed sample.
    if p**r > 20000:
        vectors = []
        for i in range(r):
            v = [0] * r
            v[i] = 1
            vectors.append(tuple(v))
        # Add simple sums to increase coverage.
        for i in range(r):
            for j in range(i + 1, min(r, 8)):
                v = [0] * r
                v[i] = 1
                v[j] = 1
                vectors.append(tuple(v))
        return list(set(vectors))  # Use set to handle duplicates

    # Otherwise, enumerate all non-zero vectors.
    return [tup for tup in product(range(p), repeat=r) if any(c != 0 for c in tup)]


def specialize_sum(ci_vec, m0, ell, cd, current_sections, p):
    """
    Specialize the F_p-linear combination (sum ci * Si) at (m0, ell).
    Returns a tuple (E0, S_sum) on success, or None on failure.
    """
    if discriminant_divisible_by_ell(cd.a4, cd.a6, m0, ell):
        return None

    E0 = None
    S_sum = None

    for i, sec in enumerate(current_sections):
        ci = int(ci_vec[i]) % p
        if ci == 0:
            continue

        res = reduce_section_at_m0(sec, m0, ell, cd.a4, cd.a6)
        if res is None:
            return None

        E0_candidate, P_mod = res
        if E0 is None:
            E0 = E0_candidate
            S_sum = E0(0)  # Initialize sum to the identity.
        
        S_sum += ci * P_mod

    if E0 is None:
        # This case happens if the ci_vec was all zeros.
        return None
    
    return E0, S_sum


def find_p_division_section(cd, current_sections, p,
                            m0_pool=None,
                            ell_min=5,
                            ell_max=300,
                            max_tests_per_relation=12,
                            verbose=True):
    """
    Searches for local evidence of a p-divisible section by checking for
    a non-trivial linear combination that specializes to the identity.
    """
    if m0_pool is None:
        m0_pool = list(range(-200, 201, 7))
        if 0 in m0_pool:
            m0_pool.remove(0)

    ell_list = [ell for ell in prime_range(ell_min, ell_max + 1) if ell != p]

    r = len(current_sections)
    if verbose:
        print(f"[find_p_division_section] Trying p={p} with r={r} sections; testing ℓ in [{ell_min},{ell_max}]")

    relations = get_fp_vectors(r, p)
    if verbose:
        print(f"[find_p_division_section] Testing {len(relations)} candidate relations (mod {p})")

    for ci_vec in relations:
        tests_done = 0
        for m0 in m0_pool:
            if tests_done >= max_tests_per_relation:
                break
            for ell in ell_list:
                if tests_done >= max_tests_per_relation:
                    break
                
                res = specialize_sum(ci_vec, m0, ell, cd, current_sections, p)
                if res is None:
                    continue

                E0, S_sum = res
                tests_done += 1

                if S_sum.is_zero():
                    if verbose:
                        print(f"[find_p_division_section] Relation {ci_vec} holds at m0={m0}, ℓ={ell}. Stored evidence.")
                    return None, {'p': p, 'status': 'evidence_found', 'm0': m0, 'ell': ell, 'relation': ci_vec}

    if verbose:
        print(f"[find_p_division_section] Tried all relations for p={p}, no constructive evidence found.")
    return None, {'p': p, 'status': 'not_found'}


def _primes_from(start=101):
    """Generator of primes starting from `start` (inclusive if prime)."""
    p = int(start)
    if not is_prime(p):
        p = int(next_prime(p))
    while True:
        yield p
        p = int(next_prime(p))


def choose_good_ell_candidates(cd, required=5, start=11, max_trial=200, verbose=False):
    """
    Dynamically choose good prime candidates ell for saturation checks.

    Criteria:
      - ell is prime >= start
      - ell is not too small (avoid 2,3,5,7)
      - ell does NOT divide any integer coefficient denominator in a4/a6
      - reduction modulo ell succeeds
      - the reduced discriminant Delta mod ell is not zero

    Returns a list of chosen primes (length <= required).
    """
    # Collect primes dividing denominators of a4, a6
    bad_den_primes = set()
    for ff in (cd.a4, cd.a6):
        try:
            den = ff.denominator()
            # Factor integer content if possible
            den_content = int(den.content()) if hasattr(den, 'content') else 1
            if den_content != 1:
                for q, _ in factor(den_content):
                    bad_den_primes.add(int(q))
        except Exception:
            # fallback: check individual coefficients
            try:
                for c in den.coefficients():
                    den_c = QQ(c).denominator()
                    if den_c != 1:
                        for q, _ in factor(den_c):
                            bad_den_primes.add(int(q))
            except Exception:
                continue

    chosen = []
    trials = 0
    gen = _primes_from(start=start)
    while len(chosen) < required and trials < max_trial:
        trials += 1
        ell = next(gen)

        # Skip very small primes and denominator divisors
        if ell < 11 or ell in bad_den_primes:
            if verbose:
                print(f"[choose_ell] Skip {ell}: too small or divides coefficient denominators")
            continue

        try:
            cd_ell = reduce_cd_mod_ell(cd, ell, debug=False)
            # Compute discriminant mod ell
            Delta = -16 * (4 * cd_ell.a4**3 + 27 * cd_ell.a6**2)
            if Delta.numerator() == 0:
                if verbose:
                    print(f"[choose_ell] Skip {ell}: discriminant collapsed modulo {ell}")
                continue
        except RuntimeError as exc:
            if verbose:
                print(f"[choose_ell] Skip {ell}: reduction failed with error: {exc}")
            continue

        chosen.append(ell)
        if verbose:
            print(f"[choose_ell] Accept {ell}")

    if verbose:
        print(f"[choose_ell] Selected {len(chosen)} primes: {chosen}")
    return chosen


def run_saturation_checks(cd, current_sections, prime_pool):
    """
    Performs and reports on p-saturation checks for p in prime_pool.

    This function first uses specialization to find witnesses that prove
    p-saturation. If no witness is found for a given prime p, it then
    searches for local evidence of a p-divisible section.
    """
    print("\n--- Running Saturation Diagnostics ---")
    
    sat_report = p_saturate_basis(cd, current_sections, prime_pool)

    for p, (is_saturated, witness) in sat_report.items():
        if is_saturated:
            print(f"✅ p={p} appears to be saturated. Witness found: {witness}")
            continue

        print(f"⚠️ p={p} saturation uncertain. Searching for evidence of p-division...")
        
        _, report = find_p_division_section(
            cd,
            current_sections,
            p,
            ell_min=5,
            ell_max=300,
            verbose=False
        )

        if report and report.get('status') == 'evidence_found':
            print(f"  -> Evidence for p={p} division was found. Report: {report}")
        else:
            print(f"  -> No evidence found for p={p} division. The lattice may be p-saturated.")


def reduce_cd_mod_ell(cd, ell, debug=False):
    """
    Robust reduction of cd.a4, cd.a6 to GF(ell)(m) rational functions.

    Returns an object cd_ell with attributes:
      - a4, a6 : elements of GF(ell)(m) (a fraction field)
      - base_field : GF(ell)
      - m_symbol : generator of the polynomial ring
    
    Raises RuntimeError for failure with a descriptive message.
    """
    try:
        ell_int = int(ell)
    except (ValueError, TypeError):
        raise ValueError(f"Cannot interpret ell={ell!r} as an integer prime.")
    
    if ell_int < 2 or not is_prime(ell_int):
        raise ValueError(f"ell must be a prime; got {ell_int!r}")

    F = GF(ell_int)
    R = PolynomialRing(F, 'm')
    R_frac = R.fraction_field()
    mF = R.gen()

    # Pre-check: Ensure coefficients don't have denominators divisible by ell.
    for coeff in cd.a4.numerator().coefficients() + cd.a4.denominator().coefficients() + \
                 cd.a6.numerator().coefficients() + cd.a6.denominator().coefficients():
        if QQ(coeff).denominator() % ell_int == 0:
            raise RuntimeError(f"Coefficient denominator {QQ(coeff).denominator()} is divisible by {ell_int}. "
                               f"This prime is unusable for robust reduction.")

    try:
        a4_mod = R_frac(cd.a4)
        a6_mod = R_frac(cd.a6)
    except Exception as exc:
        raise RuntimeError(f"Failed to coerce a4 or a6 to GF({ell_int})(m): {exc}") from exc

    if a4_mod.denominator() == 0 or a6_mod.denominator() == 0:
        raise RuntimeError(f"Denominator of a4 or a6 reduces to zero polynomial modulo {ell_int}; this prime is unusable.")

    class CDMod:
        def __init__(self, a4, a6, base_field, m_symbol):
            self.a4 = a4
            self.a6 = a6
            self.base_field = base_field
            self.m_symbol = m_symbol
            # Carry over optional attributes
            self.phi_x = getattr(cd, "phi_x", None)
            self.k_base_change = getattr(cd, "k_base_change", None)
            self.tate_exponent = getattr(cd, "tate_exponent", None)
            self.blowup_factor = getattr(cd, "blowup_factor", None)

    return CDMod(a4_mod, a6_mod, F, mF)
